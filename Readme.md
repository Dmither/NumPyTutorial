# NumPy tutorial

NumPy (Numerical Python) - бібліотека для роботи з масивами.  
Має ф-ї для лінійної алгебри, перетворення Фур'є та матриць.  
Надає об'єкт масиву, набагато швидший за стандартні списки.

## Основи NumPy

**Встановлення та імпорт**  
`$ pip install numpy` встановити для поточного оточення  
`import numpy`, `import numpy as np` підключити до робочого файлу  
`print(np.__version__)` повертає версію  

**Створення масивів**  
`arr = np.array([1, 2, 3])` створити масив на основі списку;  
приймає будь-який контейнерний тип;  
аргумент `ndim=n` задає кількість вимірів  

**Доступ до елементів, зрізи**  
Індексація, негативна індексація, зрізи одновимірних масивів  
відповідно до загальних правил контейнерних типів  
`arr[1, 2]` повертає 3 елемент 2 рядка двомірного масиву  
`arr[1:3, 2:5]` повертає матрицю зрізів [2:5] рядрів [1:3]

**Типи даних**  
`i` ціле, `b` логічне, `u` ціле без знаку, `f` дробове,  
`c` комплексне дробове, `m` дельта часу, `M` дата/час,  
`O` об'єкт, `S` рядок, `U` рядок Unicode,  
`V` фіксований шматок пам'яті для інших типів (void)  
`arr.dtype` поаертає тип даних масива  
`np.array([1, 2, 3], dtype='S')` задає тип даних  
для `i`, `u`, `f`, `S`, `U` можна визначити розмір (i4 - 4 байти)  
за неможливості перетворити тип видає ValueError  
`arr.astype('i')`, `arr.astype(int)` поверне масив перетворених  

**Копія та перегляд**  
Копія володіє власними даними, перегляд - ні.  
`arr.copy()` повертає копію масива, зміни не розповсюджуються  
`arr.view()` повертає новий вигляд масиву з тими ж даними;  
зміна даних у вихідноому масиві або представленнях змінюють всюди  
`arr.base()` повертає None, якщо масив володіє власними даними  
або вихідний масив, якщо власними даними не володіє

**Форма масиву**  
Форма масиву - кількість елементів в кожному вимірі  
`arr.shape` повертає форму ((2, 3) для [[1, 2, 3], [4, 5, 6]])  
`arr.reshape(3, 2)` повертає масив відповідно до форми;  
форма може бути змінена лише відповідно до кількості елементів;  
reshape повертає представлення (зміна елемента);  
останній вимір може бути визначено автоматично reshape(2, -1)  

**Ітерації**  
Ітерації проходять відповідно до стандартного ітерування python  
`for item in arr:` ітерується по першому рівню вкладеності;  
вкладені цикли дають змогу ітерувати глибше  
`for item in np.nditer(arr)` надає глибоке ітерування;  
для зміни типу додатково `flags=['buffered'], op_dtypes=['S']`  
`for item in np.nditer(arr[:, ::2])` діапазон за правилами зрізів  
`for i, x in np.ndenumerate(arr):` надає кортеж індексів  

**Об'єднання масивів**  
`np.concatenate()` повертає об'єднання масивів;  
перший аргумент примає кортеж насивів, які необхідно об'єднати;  
другий (необов.) аргумент - вісь, за якою об'єднати (за ум.: 0)  
`np.concat()` - коротка версія методу concatenate  
`np.stack()` повертає об'єднання масивів вздовж нової осі  
`np.hstack()` - укладання в стек вздовж рядків  
`np.vstack()` - укладання в стек вздовж стовпців  
`np.dstack()` - укладання в стек по виситі, що дорівнює глибині  

**Розбиття масивів**  
`np.array_split(arr, 3)` повертає список масивів (3);  
`np.split(arr, 3)` повертає список масивів  
за недостатньої кількості array_split створює менші масиви,  
split - видає ValueError  
Обидва методи підтримують вісь (аналогічно з concatenate)  
Також є методи `hsplit`, `vsplit`, `dsplit`, протилежні стекам

**Пошук в масивах**  
Умова масиву (arr cond) має вигляд (arr%2 == 0),  
виражає масив, елементи якого перевіряються, і умову для них  
`np.where(arr cond)` повертає кортеж з масивом індексів,  
які підходять відповідно умови;  
`np.searchsorted(arr, 7)` повертає індекс куди треба вставити  
значення, при наявності рівного повертає попередній індекс,  
аргумент `side='right'` при наявності рівного повертає наступний  
Приймає масив для пошуку `np.searchsorted(arr, [2, 4, 5])`  
поверне масив індексів кути треба вставити у відповідному порядку  

**Сортування масивів**  
`np.sort(arr)` повертає відсортовану копію масива  
Сортування двомірного масива сортує елементи в останньому вимірі  

**Фільтрація масивів**  
Фільтрація відбувається на основі логічного списку індексів  
(списку логічних значень, що відповідають індексам)  
`arr[ll]` повертає відфільтровану копію масива  
Логічний список може бути заповнений на основі умови в циклі:  
`for i in arr: ll.append(True) if i%2==0 else ll.append(False)`;  
або заповнений за допомогою умови масиву: `ll = arr%2==0`  

```py
arr = np.array([1, 2, 3, 4])
ll = arr % 2 == 0  
print(ll)       # [False, True, False, True]
print(arr[ll])  # [2 4 6]
```

## Випадкові числа в NumPy

**Випадкові числа та їх розподіл**  
NumPy random надає засоби генерування псевдовипадкових чисел  
для роботи необхідно підключити `from numpy import random`  
`random.randint(10)` повертає випадкове ціле від 0 до 9 включно  
`random.randint(10, size=(3, 5))` повертає масив випадкових цілих  
`random.rand()` повертає випадкове дробове від 0 до 1  
`random.rand(3, 5)` повертає масив випадкових дробових  
`random.choice(arr)` повертає випадкове значення масиву  
`random.choice(arr, size=(3, 5))` повертає масив випад. значень  
`random.choice([1, 2, 3], p=[0.1, 0.4, 0.6], size=(3, 5))`  
повертає масив випадкових значень зі вказаною імовірністю  
сумарна імовірність повинна складати 1  

**Випадкові перестановки елементів**  
`random.shuffle(arr)` перемішує вихідний масив, повертає None  
`random.permutation(arr)` перемішує і повертає копію масива  

**Бібліотека візуалізації Seaborn**  
для побудови графіків, візуалізації випадкових розподілів.  
kdeplot надає криву щільності

```py
import matplotlib.pyplot as plt
import seaborn as sns
sns.kdeplot([0, 1, 2, 3, 4, 5])
plt.show()
```

**Нормальний розподіл (розподіл Гауса)**  
Один із найважливіших безперервних розподілів теорії ймовірності  
Відповідає розподілу багатьох подій (н-д влучність гармати)  
Графік має форму дзвона (ймовірність зростає ближче до центру)  
`random.normal()` повертає таблицю нормального розподілу даних  
`loc=` вершина графіка (приціл гармати)  
`scale=` стандартне відхилення (влучність гармати)  
`size=` форма масиву значень

**Біноміальний розподіл**  
Дискретний розподіл, рез-т бінарних сценаріїв (падіння монети)  
Навідміну від безперервного, значення визначаються цілими числами  
За достатньої кількості точок даних графік схожий на нормальний  
`random.normal(loc=50, scale=5, size=1000)`  
`random.binomial(n=100, p=0.5, size=1000)`  
`n=` кількість випробувань (кидків монети)  
`p=` ймовірність появи кожної спроби (ймовірність герба)  
`size` форма масиву значень (ітерації експериментів)  
(експеримент 100 кидків монети 50% випадіння проведено 1000 раз)

